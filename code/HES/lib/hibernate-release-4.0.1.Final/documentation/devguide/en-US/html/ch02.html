<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 2. Transactions and concurrency control</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Hibernate Developer Guide"/><link rel="up" href="index.html" title="Hibernate Developer Guide"/><link rel="prev" href="ch01.html" title="Chapter 1. Database access"/><link rel="next" href="ch03.html" title="Chapter 3. Persistence Contexts"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch01.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch03.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1001"/>Chapter 2. Transactions and concurrency control</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch02.html#d0e1004">2.1. Defining Transaction</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1022">2.2. Physical Transactions</a></span></dt><dd><dl><dt><span class="section"><a href="ch02.html#d0e1055">2.2.1. Physical Transactions - JDBC</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1069">2.2.2. Physical Transactions - JTA</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1087">2.2.3. Physical Transactions - CMT</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1105">2.2.4. Physical Transactions - Custom</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1129">2.2.5. Physical Transactions - Legacy</a></span></dt></dl></dd><dt><span class="section"><a href="ch02.html#d0e1162">2.3. Hibernate Transaction Usage</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1178">2.4. Transaction Scopes</a></span></dt><dd><dl><dt><span class="section"><a href="ch02.html#session-per-operation">2.4.1. Session-per-operation</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1198">2.4.2. Session-per-request</a></span></dt><dt><span class="section"><a href="ch02.html#long-conversations">2.4.3. Conversations</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1327">2.4.4. Object identity</a></span></dt><dt><span class="section"><a href="ch02.html#transaction-antipatterns">2.4.5. Problems and anti-patterns</a></span></dt></dl></dd><dt><span class="section"><a href="ch02.html#hibernate-transaction-api">2.5. Hibernate Transaction API (JTA)</a></span></dt><dd><dl><dt><span class="section"><a href="ch02.html#d0e1450">2.5.1. Bean-managed transactions (BMT)</a></span></dt><dt><span class="section"><a href="ch02.html#d0e1472">2.5.2. Container-managed transactions (CMT)</a></span></dt></dl></dd></dl></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1004"/>2.1. Defining Transaction</h2></div></div></div><p>
            It is important to understand that the term transaction has many related, yet different meanings in regards
            to persistence and Object/Relational Mapping.  In most use cases these definitions align, but that is not
            always the case.
        </p><div class="itemizedlist"><ul><li><p>
                    It might refer to the physical transaction with the database.
                </p></li><li><p>
                    It might refer to the logical notion of a transaction as related to a persistence context.
                </p></li><li><p>
                    It might refer to the application notion of a Unit-of-Work, as defined by the archetypal pattern.
                </p></li></ul></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="note"><h2>Note</h2><p>
                This documentation largely treats the physical and logic notions of transaction as one-in-the-same.
            </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1022"/>2.2. Physical Transactions</h2></div></div></div><p>
            Hibernate uses the JDBC API for persistence.  In the world of Java there are 2 well defined mechanism
            for dealing with transactions in JDBC: JDBC, itself, and JTA.  Hibernate supports both mechanisms for
            integrating with transactions and allowing applications to manage physical transactions.
        </p><p>
            The first concept in understanding Hibernate transaction support is the
            <code class="interfacename">org.hibernate.engine.transaction.spi.TransactionFactory</code> interface which
            serves 2 main functions:
        </p><div class="itemizedlist"><ul><li><p>
                    It allows Hibernate to understand the transaction semantics of the environment.  Are we operating
                    in a JTA environment?  Is a physical transaction already currently active?  etc.
                </p></li><li><p>
                    It acts as a factory for <code class="interfacename">org.hibernate.Transaction</code> instances which
                    are used to allow applications to manage and check the state of transactions.
                    <code class="interfacename">org.hibernate.Transaction</code> is Hibernate's notion of a logical
                    transaction.  JPA has a similar notion in the
                    <code class="interfacename">javax.persistence.EntityTransaction</code> interface.
                </p></li></ul></div><p>
            <code class="interfacename">org.hibernate.engine.transaction.spi.TransactionFactory</code> is a standard
            Hibernate service.  See <a href="ch07.html#services-TransactionFactory" title="7.5.16. org.hibernate.engine.transaction.spi.TransactionFactory">Section 7.5.16, “<code class="interfacename">org.hibernate.engine.transaction.spi.TransactionFactory</code>”</a> for details.
        </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1055"/>2.2.1. Physical Transactions - JDBC</h3></div></div></div><p>
                JDBC-based transaction management leverages the JDBC defined methods
                <code class="methodname">java.sql.Connection.commit()</code> and
                <code class="methodname">java.sql.Connection.rollback()</code> (JDBC does not define and explicit
                method of beginning a transaction).  In Hibernate, this approach is represented by the
                <code class="classname">org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</code> class.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1069"/>2.2.2. Physical Transactions - JTA</h3></div></div></div><p>
                JTA-based transaction management leverages the JTA
                <code class="interfacename">javax.transaction.TransactionManager</code> interface as obtained from
                <code class="interfacename">org.hibernate.service.jta.platform.spi.JtaPlatform</code> API.  This approach
                is represented by the
                <code class="classname">org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</code> class.
            </p><p>
                See <a href="ch07.html#services-JtaPlatform" title="7.5.9. org.hibernate.service.jta.platform.spi.JtaPlatform">Section 7.5.9, “<code class="interfacename">org.hibernate.service.jta.platform.spi.JtaPlatform</code>”</a> for information on integration with the underlying JTA
                system.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1087"/>2.2.3. Physical Transactions - CMT</h3></div></div></div><p>
                CMT-based transaction management leverages the
                <code class="interfacename">javax.transaction.UserTransaction</code> interface as obtained from
                <code class="interfacename">org.hibernate.service.jta.platform.spi.JtaPlatform</code> API.  This approach
                is represented by the
                <code class="classname">org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</code> class.
            </p><p>
                See <a href="ch07.html#services-JtaPlatform" title="7.5.9. org.hibernate.service.jta.platform.spi.JtaPlatform">Section 7.5.9, “<code class="interfacename">org.hibernate.service.jta.platform.spi.JtaPlatform</code>”</a> for information on integration with the underlying JTA
                system.
            </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1105"/>2.2.4. Physical Transactions - Custom</h3></div></div></div><p>
                Its is also possible to plug in ones own transaction approach by implementing the
                <code class="interfacename">org.hibernate.engine.transaction.spi.TransactionFactory</code> contract.
                The default service initiator has built-in support for understanding custom transaction approaches
                via the <code class="literal">hibernate.transaction.factory_class</code> which can name either:
            </p><div class="itemizedlist"><ul><li><p>
                        The instance of <code class="interfacename">org.hibernate.engine.transaction.spi.TransactionFactory</code>
                        to use.
                    </p></li><li><p>
                        The name of a class implementing
                        <code class="interfacename">org.hibernate.engine.transaction.spi.TransactionFactory</code>
                        to use.  The expectation is that the implementation class have a no-argument constructor.
                    </p></li></ul></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1129"/>2.2.5. Physical Transactions - Legacy</h3></div></div></div><p>
                During development of 4.0, most of these classes named here were moved to new packages.  To help
                facilitate upgrading, Hibernate will also recognize the legacy names here for a short period of time.
            </p><div class="itemizedlist"><ul><li><p>
                        <code class="literal">org.hibernate.transaction.JDBCTransactionFactory</code> is mapped to
                        <code class="classname">org.hibernate.engine.transaction.internal.jdbc.JdbcTransactionFactory</code>
                    </p></li><li><p>
                        <code class="literal">org.hibernate.transaction.JTATransactionFactory</code> is mapped to
                        <code class="classname">org.hibernate.engine.transaction.internal.jta.JtaTransactionFactory</code>
                    </p></li><li><p>
                        <code class="literal">org.hibernate.transaction.CMTTransactionFactory</code> is mapped to
                        <code class="classname">org.hibernate.engine.transaction.internal.jta.CMTTransactionFactory</code>
                    </p></li></ul></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1162"/>2.3. Hibernate Transaction Usage</h2></div></div></div><p>
            Hibernate uses JDBC connections and JTA resources directly, without adding any additional locking behavior.
            It is important for you to become familiar with the JDBC, ANSI SQL, and transaction isolation specifics
            of your database management system.
        </p><p>
            Hibernate does not lock objects in memory.  The behavior defined by the isolation level of your database
            transactions does not change when you use Hibernate.  The Hibernate
            <code class="interfacename">org.hibernate.Session</code> acts as a transaction-scoped cache providing
            repeatable reads for lookup by identifier and entity queries and not-reporting queries that return scalar
            values.
        </p></div><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="important"><h2>Important</h2><p>
            To reduce lock contention in the database, a database transaction needs to be as short as possible.  Long
            database transactions prevent your application from scaling to a highly-concurrent load.  Do not hold a
            database transaction open during end-user-level work, but open it after the end-user-level work is finished.
            This is concept is referred to as <code class="literal">transactional write-behind</code>.
        </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1178"/>2.4. Transaction Scopes</h2></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="session-per-operation"/>2.4.1. Session-per-operation</h3></div><div><h4 class="subtitle">Anti-patterns to avoid</h4></div></div></div><p>
        <em class="firstterm">Session-per-operation</em> refers to the anti-pattern of opening and closing a
        <code class="classname">Session</code> for each database call in a single thread. It is also an anti-pattern in terms of
        database transactions. Group your database calls into a planned sequence. In the same way, do not auto-commit
        after every SQL statement in your application. Hibernate disables, or expects the application server to disable,
        auto-commit mode immediately. Database transactions are never optional. All communication with a database must
        be encapsulated by a transaction. Avoid auto-commit behavior for reading data, because many small transactions
        are unlikely to perform better than one clearly-defined unit of work, and are more difficult to maintain and
        extend.
      </p><p>
        For more anti-patterns to avoid, see <a href="ch02.html#transaction-antipatterns" title="2.4.5. Problems and anti-patterns">Section 2.4.5, “Problems and anti-patterns”</a>.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1198"/>2.4.2. Session-per-request</h3></div><div><h4 class="subtitle">The typical desired pattern</h4></div></div></div><p>
        The most common pattern in a multi-user client/server application is
        <em class="firstterm">session-per-request</em>. In this model, a client sends a request to the server, where the
        Hibernate persistence layer is running. Hibernate opens a new Session, and all database operations are executed
        in this unit of work. After the work is completed, and the server prepares the response for the client, the
        session is flushed and closed. Use a single database transaction to serve the clients request, starting and
        committing it when you open and close the Session. The relationship between the transaction and the Session is
        one-to-one.
      </p><p>
        Hibernate provides built-in management of the <em class="firstterm">current session</em> to
        simplify the session-per-request pattern. Start a transaction to process a server request, and end the transaction
        before sending the response to the client. Common solutions include:
      </p><div class="itemizedlist"><ul><li><p>
            ServletFilter
          </p></li><li><p>
            AOP interceptor with a pointcut on the service methods
          </p></li><li><p>
            A proxy/interception container
          </p></li></ul></div><p>
        An EJB container is a standardized way to implement cross-cutting aspects such as transaction demarcation on EJB
        session beans in a declarative manner with CMT. If you prefer programmatic transaction demarcation, see
          <a href="ch02.html#hibernate-transaction-api" title="2.5. Hibernate Transaction API (JTA)">Section 2.5, “Hibernate Transaction API (JTA)”</a>.
      </p><p>
        To access a current session to process the request, call method
        <code class="methodname">sessionFactory.getCurrentSession()</code>. The returned <code class="classname">Session</code> is
        scoped to the current database transaction. You need to configure this for either resource-local or JTA
        environments
      </p><p>
        You can extend the scope of a <code class="classname">Session</code> and database transaction until the view is
        rendered. This is especially useful in servlet applications that include a separate rendering phase after the
        request is processed. To extending the database transaction until view rendering, implement your own
        interceptor. This implementation is difficult if you rely on EJBs with container-managed transactions. A
        transaction is completed when an EJB method returns, before rendering of any view can start. Search the
        Hibernate forums for tips and examples relating to this <span>Open Session in View</span> pattern.
      </p><p>
        If <span>session-per-request</span> does not seem well-suited for your application, refer to <a href="ch02.html#long-conversations" title="2.4.3. Conversations">Section 2.4.3, “Conversations”</a> for another choice.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="long-conversations"/>2.4.3. Conversations</h3></div><div><h4 class="subtitle">An alternate pattern to <span>session-per-request</span></h4></div></div></div><p>
        The <span>session-per-request</span> pattern is not the only way of designing units of work. Many business
        processes require a whole series of interactions with the user that are interleaved with database accesses. In web
        and enterprise applications, it is not acceptable for a database transaction to span a user interaction. Consider
        the following example:
      </p><div xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="procedure"><a id="d0e1262"/><p class="title"><b>Procedure 2.1. An example of a long-running conversation</b></p><ol class="1"><li><p>
            The first screen of a dialog opens. The data seen by the user is loaded in a particular
            <code class="classname">Session</code> and database transaction. The user is free to modify the objects.
          </p></li><li><p>
            The user uses a UI element to save their work after five minutes of editing. The modifications are made
            persistent. The user also expects to have exclusive access to the data during the edit session.
          </p></li></ol></div><p>
        From the point of view of the user, this unit of work is a long-running conversation or application
        transaction. There are many ways to implement this in your application.
      </p><p>
        A first naive implementation might keep the <code class="classname">Session</code> and database transaction open while the
        user is editing, using database-level locks to prevent other users from modifying the same data and to guarantee
        isolation and atomicity. This is an anti-pattern, because lock contention is a bottleneck which will prevent
        scalability in the future.
      </p><p>
        Several database transactions are used to implement the conversation. In this case, maintaining isolation
        of business processes becomes the partial responsibility of the application tier. A single conversation usually
        spans several database transactions. It is atomic if only one of these database transactions, typically the last one,
        stores the updated data. All others only read data. A common way to receive this data is through a wizard-style
        dialog spanning several request/response cycles. Hibernate includes some features which make this easy to implement.
      </p><div class="informaltable"><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
                <p>
                  Automatic Versioning
                </p>
              </td><td>
                <p>
                  Hibernate can perform automatic optimistic concurrency control for you. It can automatically detect if a
                  concurrent modification occurred during user think time. Check for this at the end of the conversation.
                </p>
              </td></tr><tr><td>
                <p>
                  Detached Objects
                </p>
              </td><td>
                <p>
                  If you decide to use the session-per-request pattern, all loaded instances will be in
                  the detached state during user think time. Hibernate allows you to reattach the objects and persist the
                  modifications. The pattern is called session-per-request-with-detached-objects. Automatic versioning is
                  used to isolate concurrent modifications.
                </p>
              </td></tr><tr><td>
                <p>
                  Extended (or Long) Session
                </p>
              </td><td>
                <p>
                  Extended (or Long) Session: the Hibernate Session can be disconnected from the underlying JDBC
                  connection after the database transaction has been committed and reconnected when a new client request
                  occurs. This pattern is known as session-per-conversation and makes even reattachment
                  unnecessary. Automatic versioning is used to isolate concurrent modifications and the Session will not
                  be allowed to be flushed automatically, but explicitly.
                </p>
              </td></tr></tbody></table></div><p>
        <span>Session-per-request-with-detached-objects</span> and <span>session-per-conversation</span> each have
        advantages and disadvantages.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1327"/>2.4.4. Object identity</h3></div></div></div><p>
        An application can concurrently access the same persistent state in two different Sessions. However, an instance
        of a persistent class is never shared between two <code class="classname">Session</code> instances. Therefore, two
        different notions of identity exist: Database identity and JVM identity.
      </p><div class="example"><a id="d0e1335"/><p class="title"><b>Example 2.1. Database identity</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">foo</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getId</span><!-- <br/> --><span class="java_separator">().</span><!-- <br/> --><span class="java_plain">equals</span><!-- <br/> --><span class="java_separator">(</span><!-- <br/> --><span class="java_plain">&nbsp;bar</span><!-- <br/> --><span class="java_separator">.</span><!-- <br/> --><span class="java_plain">getId</span><!-- <br/> --><span class="java_separator">()</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_separator">)</span></pre></div></div><br class="example-break"/><div class="example"><a id="d0e1340"/><p class="title"><b>Example 2.2. JVM identity</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">foo</span><!-- <br/> --><span class="java_operator">==</span><!-- <br/> --><span class="java_plain">bar</span></pre></div></div><br class="example-break"/><p>
        For objects attached to a particular Session, the two notions are equivalent, and JVM identity for database
        identity is guaranteed by Hibernate. The application might concurrently access a business object with the same
        identity in two different sessions, the two instances are actually different, in terms of JVM
        identity. Conflicts are resolved using an optimistic approach and automatic versioning at flush/commit time.
      </p><p>
        This approach places responsibility for concurrency on Hibernate and the database. It also provides the best
        scalability, since expensive locking is not needed to guarantee identity in single-threaded units of work. The
        application does not need to synchronize on any business object, as long as it maintains a single thread per
        <code class="classname">Session</code>. Within a <code class="classname">Session</code> the application can safely use the
        <code class="literal">==</code> operator to compare objects.
      </p><p>
        However, an application that uses the <code class="literal">==</code> operator outside of a <code class="classname">Session</code>
        may introduce problems.. If you put two detached instances into the same <code class="classname">Set</code>, they might
        use the same database identity, which means they represent the same row in the database. They would not be
        guaranteed to have the same JVM identity if they are in a detached state. Override the
        <code class="methodname">equals</code> and <code class="methodname">hashCode</code> methods in persistent classes, so that
        they have their own notion of object equality. Never use the database identifier to implement equality. Instead,
        use a business key that is a combination of unique, typically immutable, attributes. The database identifier
        changes if a transient object is made persistent. If the transient instance, together with detached instances,
        is held in a <code class="classname">Set</code>, changing the hash-code breaks the contract of the
        <code class="classname">Set</code>. Attributes for business keys can be less stable than database primary keys. You only
        need to guarantee stability as long as the objects are in the same <code class="classname">Set</code>.This is not a
        Hibernate issue, but relates to Java's implementation of object identity and equality.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="transaction-antipatterns"/>2.4.5. Problems and anti-patterns</h3></div></div></div><p>
        Avoid the anti-patterns session-per-user-session or session-per-application, for the most part. The reasons are
        outlined in <a href="ch02.html#session-per-operation" title="2.4.1. Session-per-operation">Section 2.4.1, “Session-per-operation”</a>. In addition, keep the following points in mind when
        choosing patterns for your application.
      </p><div class="variablelist"><dl><dt><span class="term">A <code class="classname">Session</code> is not thread-safe.</span></dt><dd><p>
              Resources, such as HTTP requests, session beans, or Swing workers, cause race conditions if a
              <code class="classname">Session</code> instance is shared. If you keep your Hibernate
              <code class="classname">Session</code> in your <code class="classname">HttpSession</code>, consider synchronizing access
              to your <code class="classname">Http</code> session. Otherwise, a reloaded application may use the same
              <code class="classname">Session</code> in two concurrently-running threads.
            </p></dd><dt><span class="term">If Hibernate throws an exception, you must rollback your database transaction and close the
          <code class="classname">Session</code> immediately.</span></dt><dd><p>
              In addition to the above, if your Session is bound to the application, you must stop the
              application. Rolling back the database transaction does not put your business objects back into their
              state at the start of the transaction. The database state and the business objects will be out of
              sync. Since exceptions are not recoverable, this is typically not a problem. You must start over after
              rollback anyway.
            </p></dd><dt><span class="term">The Session caches every object that is in a persistent state.</span></dt><dd><p>
              A persistent state refers to objects that are watched and checked for dirty state by Hibernate. If you
              keep the cache open for a long time or load too much data, it grows to fill available memory, causing an
              OutOfMemoryException.
            </p><p>
              To solve this problem, you can call <code class="methodname">clear()</code> and <code class="methodname">evict()</code>
              to manage the <code class="classname">Session</code> cache. Alternately, you can use a Stored Procedure if you
              need mass data operations. Keeping a <code class="classname">Session</code> open for the duration of a user
              session reduces the probability of stale data.
            </p></dd></dl></div></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="hibernate-transaction-api"/>2.5. Hibernate Transaction API (JTA)</h2></div></div></div><p>
      If your persistence layer runs in an application server, such as behind EJB session beans, every datasource
      connection obtained by Hibernate is automatically part of the global JTA transaction. You can also install a
      standalone JTA implementation and use it without EJB. Hibernate offers two strategies for JTA integration.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1450"/>2.5.1. Bean-managed transactions (BMT)</h3></div></div></div><p>
        If you use bean-managed transactions (BMT), Hibernate tells the application server to start and end a BMT
        transaction if you use the Transaction API. The transaction management code is identical to the non-managed
        environment.
      </p><div class="example"><a id="d0e1455"/><p class="title"><b>Example 2.3. BMT idiom</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">openSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Transaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">beginTransaction</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;sess</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/><p>
        Alternately, you can use a transaction-bound Session. If you need the
        <code class="methodname">getCurrentSession()</code> functionality for easy context propagation, use the JTA
        UserTransaction API directly.
      </p><div class="example"><a id="d0e1465"/><p class="title"><b>Example 2.4. BMT idiom with <code class="methodname">getCurrentSession()</code></b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom&nbsp;with&nbsp;getCurrentSession</span><!-- <br/> --><span class="java_separator">()</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">UserTransaction</span><span class="java_separator">)</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">InitialContext</span><span class="java_separator">()</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">.</span><span class="java_plain">lookup</span><span class="java_separator">(</span><span class="java_literal">&quot;java:comp/UserTransaction&quot;</span><span class="java_separator">);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">Do</span><span class="java_plain">&nbsp;some&nbsp;work&nbsp;on&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;bound&nbsp;to&nbsp;transaction</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">load</span><span class="java_separator">(...);</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">().</span><span class="java_plain">persist</span><span class="java_separator">(...);</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span></pre></div></div><br class="example-break"/></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1472"/>2.5.2. Container-managed transactions (CMT)</h3></div></div></div><p>
        With CMT, transaction demarcation is declared in session bean deployment descriptors, rather than performed in
          a programmatic manner.  This reduces the amount of code.
      </p><div class="example"><a id="d0e1477"/><p class="title"><b>Example 2.5. CMT idiom</b></p><div class="example-contents"><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;CMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_type">Session</span><span class="java_plain">&nbsp;sess&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">getCurrentSession</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;</span><span class="java_separator">...</span>
</pre></div></div><br class="example-break"/><p>
        In a CMT/EJB, rollback happens automatically as well. An unhandled <code class="systemitem">RuntimeException</code>
        thrown by a session bean method tells the container to set the global transaction to rollback. You do not need
        to intervene, and you get automatic propagation of the <code class="classname">Current</code>
        <code class="classname">Session</code> bound to the transaction.
      </p><p>
        When configuring Hibernate's transaction factory, choose
        <code class="classname">org.hibernate.transaction.JTATransactionFactory</code> if you use JTA directly (BMT), and
        <code class="classname">org.hibernate.transaction.CMTTransactionFactory</code> in a CMT session bean. Set the
        <code class="varname">hibernate.transaction.manager_lookup_class</code> property as well. Ensure that your
        <code class="classname">hibernate.current_session_context_class</code> is either unset, or is set to
        <code class="literal">jta</code>.
      </p><p>
        The <code class="methodname">getCurrentSession()</code> method has one downside in a JTA environment. If you use it,
        after_statement connection release mode is also used by default. Due to a limitation of the JTA specification,
        Hibernate cannot automatically clean up any unclosed <code class="classname">ScrollableResults</code> or
        <code class="classname">Iterator</code> instances returned by <code class="methodname">scroll()</code> or
        <code class="methodname">iterate()</code>. Release the underlying database cursor by calling
        <code class="methodname">ScrollableResults.close()</code> or <code class="methodname">Hibernate.close(Iterator)</code>
        explicitly from a <code class="systemitem">finally</code> block. Try to avoid using <code class="methodname">scroll()</code>
        or <code class="methodname">iterate()</code> from the JTA or CMT code.
      </p></div></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2011 Red Hat, Inc.</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="ch01.html"><strong>Prev</strong>Chapter 1. Database access</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="ch03.html"><strong>Next</strong>Chapter 3. Persistence Contexts</a></li></ul></body></html>