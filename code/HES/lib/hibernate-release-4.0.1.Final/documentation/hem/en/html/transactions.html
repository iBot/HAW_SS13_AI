<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 5. Transactions and Concurrency</title><link rel="stylesheet" href="css/hibernate.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.72.0"/><link rel="start" href="index.html" title="Hibernate EntityManager"/><link rel="up" href="index.html" title="Hibernate EntityManager"/><link rel="prev" href="metamodel.html" title="Chapter 4. Metamodel"/><link rel="next" href="listeners.html" title="Chapter 6. Entity listeners and Callback methods"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="metamodel.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="listeners.html"><strong>Next</strong></a></li></ul><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="transactions"/>Chapter 5. Transactions and Concurrency</h2></div></div></div><div class="toc"><dl><dt><span class="sect1"><a href="transactions.html#transactions-basics">5.1. Entity manager and transaction scopes</a></span></dt><dd><dl><dt><span class="sect2"><a href="transactions.html#transactions-basics-uow">5.1.1. Unit of work</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-basics-apptx">5.1.2. Long units of work</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-basics-identity">5.1.3. Considering object identity</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-basics-issues">5.1.4. Common concurrency control issues</a></span></dt></dl></dd><dt><span class="sect1"><a href="transactions.html#transactions-demarcation">5.2. Database transaction demarcation</a></span></dt><dd><dl><dt><span class="sect2"><a href="transactions.html#transactions-demarcation-nonmanaged">5.2.1. Non-managed environment</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-demarcation-jta">5.2.2. Using JTA</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-demarcation-exceptions">5.2.3. Exception handling</a></span></dt></dl></dd><dt><span class="sect1"><a href="transactions.html#d0e2798">5.3. EXTENDED Persistence Context</a></span></dt><dd><dl><dt><span class="sect2"><a href="transactions.html#d0e2839">5.3.1. Container Managed Entity Manager</a></span></dt><dt><span class="sect2"><a href="transactions.html#d0e2857">5.3.2. Application Managed Entity Manager</a></span></dt></dl></dd><dt><span class="sect1"><a href="transactions.html#transactions-optimistic">5.4. Optimistic concurrency control</a></span></dt><dd><dl><dt><span class="sect2"><a href="transactions.html#transactions-optimistic-manual">5.4.1. Application version checking</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-optimistic-longsession">5.4.2. Extended entity manager and automatic versioning</a></span></dt><dt><span class="sect2"><a href="transactions.html#transactions-optimistic-detached">5.4.3. Detached objects and automatic versioning</a></span></dt></dl></dd></dl></div><p>The most important point about Hibernate Entity Manager and
  concurrency control is that it is very easy to understand. Hibernate Entity
  Manager directly uses JDBC connections and JTA resources without adding any
  additional locking behavior. We highly recommend you spend some time with
  the JDBC, ANSI, and transaction isolation specification of your database
  management system. Hibernate Entity Manager only adds automatic versioning
  but does not lock objects in memory or change the isolation level of your
  database transactions. Basically, use Hibernate Entity Manager like you
  would use direct JDBC (or JTA/CMT) with your database resources.</p><p>We start the discussion of concurrency control in Hibernate with the
  granularity of <code class="literal">EntityManagerFactory</code>, and
  <code class="literal">EntityManager</code>, as well as database transactions and long
  units of work..</p><p>In this chapter, and unless explicitly expressed, we will mix and
  match the concept of entity manager and persistence context. One is an API
  and programming object, the other a definition of scope. However, keep in
  mind the essential difference. A persistence context is usually bound to a
  JTA transaction in Java EE, and a persistence context starts and ends at
  transaction boundaries (transaction-scoped) unless you use an extended
  entity manager. Please refer to <a href="architecture.html#architecture-ejb-persistctxscope" title="1.2.3. Persistence context scope">Section 1.2.3, “Persistence context scope”</a> for more information.</p><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-basics"/>5.1. Entity manager and transaction scopes</h2></div></div></div><p>A <code class="literal">EntityManagerFactory</code> is an expensive-to-create,
    threadsafe object intended to be shared by all application threads. It is
    created once, usually on application startup.</p><p>An <code class="literal">EntityManager</code> is an inexpensive,
    non-threadsafe object that should be used once, for a single business
    process, a single unit of work, and then discarded. An
    <code class="literal">EntityManager</code> will not obtain a JDBC
    <code class="literal">Connection</code> (or a <code class="literal">Datasource</code>) unless
    it is needed, so you may safely open and close an
    <code class="literal">EntityManager</code> even if you are not sure that data access
    will be needed to serve a particular request. (This becomes important as
    soon as you are implementing some of the following patterns using request
    interception.)</p><p>To complete this picture you also have to think about database
    transactions. A database transaction has to be as short as possible, to
    reduce lock contention in the database. Long database transactions will
    prevent your application from scaling to highly concurrent load.</p><p>What is the scope of a unit of work? Can a single Hibernate
    <code class="literal">EntityManager</code> span several database transactions or is
    this a one-to-one relationship of scopes? When should you open and close a
    <code class="literal">Session</code> and how do you demarcate the database
    transaction boundaries?</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-uow"/>5.1.1. Unit of work</h3></div></div></div><p>First, don't use the
      <span class="emphasis"><em>entitymanager-per-operation</em></span> antipattern, that is,
      don't open and close an <code class="literal">EntityManager</code> for every
      simple database call in a single thread! Of course, the same is true for
      database transactions. Database calls in an application are made using a
      planned sequence, they are grouped into atomic units of work. (Note that
      this also means that auto-commit after every single SQL statement is
      useless in an application, this mode is intended for ad-hoc SQL console
      work.)</p><p>The most common pattern in a multi-user client/server application
      is <span class="emphasis"><em>entitymanager-per-request</em></span>. In this model, a
      request from the client is send to the server (where the JPA persistence
      layer runs), a new <code class="literal">EntityManager</code> is opened, and all
      database operations are executed in this unit of work. Once the work has
      been completed (and the response for the client has been prepared), the
      persistence context is flushed and closed, as well as the entity manager
      object. You would also use a single database transaction to serve the
      clients request. The relationship between the two is one-to-one and this
      model is a perfect fit for many applications.</p><p>This is the default JPA persistence model in a Java EE environment
      (JTA bounded, transaction-scoped persistence context); injected (or
      looked up) entity managers share the same persistence context for a
      particular JTA transaction. The beauty of JPA is that you don't have to
      care about that anymore and just see data access through entity manager
      and demarcation of transaction scope on session beans as completely
      orthogonal.</p><p>The challenge is the implementation of this (and other) behavior
      outside an EJB3 container: not only has the
      <code class="literal">EntityManager</code> and resource-local transaction to be
      started and ended correctly, but they also have to be accessible for
      data access operations. The demarcation of a unit of work is ideally
      implemented using an interceptor that runs when a request hits the
      non-EJB3 container server and before the response will be send (i.e. a
      <code class="literal">ServletFilter</code> if you are using a standalone servlet
      container). We recommend to bind the <code class="literal">EntityManager</code> to
      the thread that serves the request, using a
      <code class="literal">ThreadLocal</code> variable. This allows easy access (like
      accessing a static variable) in all code that runs in this thread.
      Depending on the database transaction demarcation mechanism you chose,
      you might also keep the transaction context in a
      <code class="literal">ThreadLocal</code> variable. The implementation patterns for
      this are known as <span class="emphasis"><em>ThreadLocal Session</em></span> and
      <span class="emphasis"><em>Open Session in View</em></span> in the Hibernate community.
      You can easily extend the <code class="literal">HibernateUtil</code> shown in the
      Hibernate reference documentation to implement this pattern, you don't
      need any external software (it's in fact very trivial). Of course, you'd
      have to find a way to implement an interceptor and set it up in your
      environment. See the Hibernate website for tips and examples. Once
      again, remember that your first choice is naturally an EJB3 container -
      preferably a light and modular one such as JBoss application
      server.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-apptx"/>5.1.2. Long units of work</h3></div></div></div><p>The entitymanager-per-request pattern is not the only useful
      concept you can use to design units of work. Many business processes
      require a whole series of interactions with the user interleaved with
      database accesses. In web and enterprise applications it is not
      acceptable for a database transaction to span a user interaction with
      possibly long waiting time between requests. Consider the following
      example:</p><div class="itemizedlist"><ul><li><p>The first screen of a dialog opens, the data seen by the user
          has been loaded in a particular <code class="literal">EntityManager</code> and
          resource-local transaction. The user is free to modify the detached
          objects.</p></li><li><p>The user clicks "Save" after 5 minutes and expects his
          modifications to be made persistent; he also expects that he was the
          only person editing this information and that no conflicting
          modification can occur.</p></li></ul></div><p>We call this unit of work, from the point of view of the user, a
      long running <span class="emphasis"><em>application transaction</em></span>. There are
      many ways how you can implement this in your application.</p><p>A first naive implementation might keep the
      <code class="literal">EntityManager</code> and database transaction open during
      user think time, with locks held in the database to prevent concurrent
      modification, and to guarantee isolation and atomicity. This is of
      course an anti-pattern, a pessimistic approach, since lock contention
      would not allow the application to scale with the number of concurrent
      users.</p><p>Clearly, we have to use several database transactions to implement
      the application transaction. In this case, maintaining isolation of
      business processes becomes the partial responsibility of the application
      tier. A single application transaction usually spans several database
      transactions. It will be atomic if only one of these database
      transactions (the last one) stores the updated data, all others simply
      read data (e.g. in a wizard-style dialog spanning several
      request/response cycles). This is easier to implement than it might
      sound, especially if you use JPA entity manager and persistence context
      features:</p><div class="itemizedlist"><ul><li><p><span class="emphasis"><em>Automatic Versioning</em></span> - An entity manager
          can do automatic optimistic concurrency control for you, it can
          automatically detect if a concurrent modification occurred during
          user think time (usually by comparing version numbers or timestamps
          when updating the data in the final resource-local
          transaction).</p></li><li><p><span class="emphasis"><em>Detached Entities</em></span> - If you decide to use
          the already discussed <span class="emphasis"><em>entity-per-request</em></span>
          pattern, all loaded instances will be in detached state during user
          think time. The entity manager allows you to merge the detached
          (modified) state and persist the modifications, the pattern is
          called
          <span class="emphasis"><em>entitymanager-per-request-with-detached-entities</em></span>.
          Automatic versioning is used to isolate concurrent
          modifications.</p></li><li><p><span class="emphasis"><em>Extended Entity Manager</em></span> - The Hibernate
          Entity Manager may be disconnected from the underlying JDBC
          connection between two client calls and reconnected when a new
          client request occurs. This pattern is known as
          <span class="emphasis"><em>entitymanager-per-application-transaction</em></span> and
          makes even merging unnecessary. An extend persistence context is
          responsible to collect and retain any modification (persist, merge,
          remove) made outside a transaction. The next client call made inside
          an active transaction (typically the last operation of a user
          conversation) will execute all queued modifications. Automatic
          versioning is used to isolate concurrent modifications.</p></li></ul></div><p>Both
      <span class="emphasis"><em>entitymanager-per-request-with-detached-objects</em></span> and
      <span class="emphasis"><em>entitymanager-per-application-transaction</em></span> have
      advantages and disadvantages, we discuss them later in this chapter in
      the context of optimistic concurrency control.</p><p>TODO: This note should probably come later.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-identity"/>5.1.3. Considering object identity</h3></div></div></div><p>An application may concurrently access the same persistent state
      in two different persistence contexts. However, an instance of a managed
      class is never shared between two persistence contexts. Hence there are
      two different notions of identity:</p><div class="variablelist"><dl><dt><span class="term">Database Identity</span></dt><dd><p><code class="literal">foo.getId().equals( bar.getId() )</code></p></dd><dt><span class="term">JVM Identity</span></dt><dd><p><code class="literal">foo==bar</code></p></dd></dl></div><p>Then for objects attached to a <span class="emphasis"><em>particular</em></span>
      persistence context (i.e. in the scope of an
      <code class="literal">EntityManager</code>) the two notions are equivalent, and
      JVM identity for database identity is guaranteed by the Hibernate Entity
      Manager. However, while the application might concurrently access the
      "same" (persistent identity) business object in two different
      persistence contexts, the two instances will actually be "different"
      (JVM identity). Conflicts are resolved using (automatic versioning) at
      flush/commit time, using an optimistic approach.</p><p>This approach leaves Hibernate and the database to worry about
      concurrency; it also provides the best scalability, since guaranteeing
      identity in single-threaded units of work only doesn't need expensive
      locking or other means of synchronization. The application never needs
      to synchronize on any business object, as long as it sticks to a single
      thread per <code class="literal">EntityManager</code>. Within a persistence
      context, the application may safely use <code class="literal">==</code> to compare
      entities.</p><p>However, an application that uses <code class="literal">==</code> outside of
      a persistence context might see unexpected results. This might occur
      even in some unexpected places, for example, if you put two detached
      instances into the same <code class="literal">Set</code>. Both might have the same
      database identity (i.e. they represent the same row), but JVM identity
      is by definition not guaranteed for instances in detached state. The
      developer has to override the <code class="literal">equals()</code> and
      <code class="literal">hashCode()</code> methods in persistent classes and
      implement his own notion of object equality. There is one caveat: Never
      use the database identifier to implement equality, use a business key, a
      combination of unique, usually immutable, attributes. The database
      identifier will change if a transient entity is made persistent (see the
      contract of the <code class="literal">persist()</code> operation). If the
      transient instance (usually together with detached instances) is held in
      a <code class="literal">Set</code>, changing the hashcode breaks the contract of
      the <code class="literal">Set</code>. Attributes for good business keys don't have
      to be as stable as database primary keys, you only have to guarantee
      stability as long as the objects are in the same <code class="literal">Set</code>.
      See the Hibernate website for a more thorough discussion of this issue.
      Also note that this is not a Hibernate issue, but simply how Java object
      identity and equality has to be implemented.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-basics-issues"/>5.1.4. Common concurrency control issues</h3></div></div></div><p>Never use the anti-patterns
      <span class="emphasis"><em>entitymanager-per-user-session</em></span> or
      <span class="emphasis"><em>entitymanager-per-application</em></span> (of course, there are
      rare exceptions to this rule, e.g. entitymanager-per-application might
      be acceptable in a desktop application, with manual flushing of the
      persistence context). Note that some of the following issues might also
      appear with the recommended patterns, make sure you understand the
      implications before making a design decision:</p><div class="itemizedlist"><ul><li><p>An entity manager is not thread-safe. Things which are
          supposed to work concurrently, like HTTP requests, session beans, or
          Swing workers, will cause race conditions if an
          <code class="literal">EntityManager</code> instance would be shared. If you
          keep your Hibernate <code class="literal">EntityManager</code> in your
          <code class="literal">HttpSession</code> (discussed later), you should
          consider synchronizing access to your Http session. Otherwise, a
          user that clicks reload fast enough may use the same
          <code class="literal">EntityManager</code> in two concurrently running
          threads. You will very likely have provisions for this case already
          in place, for other non-threadsafe but session-scoped
          objects.</p></li><li><p>An exception thrown by the Entity Manager means you have to
          rollback your database transaction and close the
          <code class="literal">EntityManager</code> immediately (discussed later in
          more detail). If your <code class="literal">EntityManager</code> is bound to
          the application, you have to stop the application. Rolling back the
          database transaction doesn't put your business objects back into the
          state they were at the start of the transaction. This means the
          database state and the business objects do get out of sync. Usually
          this is not a problem, because exceptions are not recoverable and
          you have to start over your unit of work after rollback
          anyway.</p></li><li><p>The persistence context caches every object that is in managed
          state (watched and checked for dirty state by Hibernate). This means
          it grows endlessly until you get an
          <code class="classname">OutOfMemoryException</code>, if you keep it open for
          a long time or simply load too much data. One solution for this is
          some kind batch processing with regular flushing of the persistence
          context, but you should consider using a database stored procedure
          if you need mass data operations. Some solutions for this problem
          are shown in <a href="batch.html" title="Chapter 7. Batch processing">Chapter 7, <i xmlns:xlink="http://www.w3.org/1999/xlink">Batch processing</i></a>. Keeping a persistence context
          open for the duration of a user session also means a high
          probability of stale data, which you have to know about and control
          appropriately.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-demarcation"/>5.2. Database transaction demarcation</h2></div></div></div><p>Database (or system) transaction boundaries are always necessary. No
    communication with the database can occur outside of a database
    transaction (this seems to confuse many developers who are used to the
    auto-commit mode). Always use clear transaction boundaries, even for
    read-only operations. Depending on your isolation level and database
    capabilities this might not be required but there is no downside if you
    always demarcate transactions explicitly. You'll have to do operations
    outside a transaction, though, when you'll need to retain modifications in
    an <code class="literal">EXTENDED</code> persistence context.</p><p>A JPA application can run in non-managed (i.e. standalone, simple
    Web- or Swing applications) and managed Java EE environments. In a
    non-managed environment, an <code class="literal">EntityManagerFactory</code> is
    usually responsible for its own database connection pool. The application
    developer has to manually set transaction boundaries, in other words,
    begin, commit, or rollback database transactions itself. A managed
    environment usually provides container-managed transactions, with the
    transaction assembly defined declaratively through annotations of EJB
    session beans, for example. Programmatic transaction demarcation is then
    no longer necessary, even flushing the <code class="literal">EntityManager</code> is
    done automatically.</p><p>Usually, ending a unit of work involves four distinct phases:</p><div class="itemizedlist"><ul compact="compact"><li><p>commit the (resource-local or JTA) transaction (this
        automatically flushes the entity manager and persistence
        context)</p></li><li><p>close the entity manager (if using an application-managed entity
        manager)</p></li><li><p>handle exceptions</p></li></ul></div><p>We'll now have a closer look at transaction demarcation and
    exception handling in both managed- and non-managed environments.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-nonmanaged"/>5.2.1. Non-managed environment</h3></div></div></div><p>If an JPA persistence layer runs in a non-managed environment,
      database connections are usually handled by Hibernate's pooling
      mechanism behind the scenes. The common entity manager and transaction
      handling idiom looks like this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">Non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">managed&nbsp;environment&nbsp;idiom</span>
<!--  --><br/><span class="java_type">EntityManager</span><span class="java_plain">&nbsp;em&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;emf</span><span class="java_separator">.</span><span class="java_plain">createEntityManager</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">EntityTransaction</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;em</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;tx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_plain">&nbsp;</span><span class="java_operator">&amp;&amp;</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">isActive</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;em</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>You don't have to <code class="literal">flush()</code> the
      <code class="literal">EntityManager</code> explicitly - the call to
      <code class="literal">commit()</code> automatically triggers the
      synchronization.</p><p>A call to <code class="literal">close()</code> marks the end of an
      <code class="literal">EntityManager</code>. The main implication of
      <code class="literal">close()</code> is the release of resources - make sure you
      always close and never outside of guaranteed finally block.</p><p>You will very likely never see this idiom in business code in a
      normal application; fatal (system) exceptions should always be caught at
      the "top". In other words, the code that executes entity manager calls
      (in the persistence layer) and the code that handles
      <code class="literal">RuntimeException</code> (and usually can only clean up and
      exit) are in different layers. This can be a challenge to design
      yourself and you should use J2EE/EJB container services whenever they
      are available. Exception handling is discussed later in this
      chapter.</p><div class="sect3" lang="en"><div class="titlepage"><div><div><h4 class="title"><a id="d0e2464"/>5.2.1.1. EntityTransaction</h4></div></div></div><p>In a JTA environment, you don't need any extra API to interact
        with the transaction in your environment. Simply use transaction
        declaration or the JTA APIs.</p><p>If you are using a <code class="literal">RESOURCE_LOCAL</code> entity
        manager, you need to demarcate your transaction boundaries through the
        <code class="literal">EntityTransaction</code> API. You can get an
        <code class="literal">EntityTransaction</code> through
        <code class="literal">entityManager.getTransaction()</code>. This
        <code class="literal">EntityTransaction</code> API provides the regular
        <code class="methodname">begin()</code>, <code class="methodname">commit()</code>,
        <code class="methodname">rollback()</code> and
        <code class="methodname">isActive()</code> methods. It also provide a way to
        mark a transaction as rollback only, ie force the transaction to
        rollback. This is very similar to the JTA operation
        <code class="methodname">setRollbackOnly()</code>. When a
        <code class="literal">commit()</code> operation fail and/or if the transaction
        is marked as <code class="literal">setRollbackOnly()</code>, the
        <code class="literal">commit()</code> method will try to rollback the
        transaction and raise a
        <code class="literal">javax.transaction.RollbackException</code>.</p><p>In a <code class="literal">JTA</code> entity manager,
        <code class="literal">entityManager.getTransaction()</code> calls are not
        permitted.</p></div></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-jta"/>5.2.2. Using JTA</h3></div></div></div><p>If your persistence layer runs in an application server (e.g.
      behind EJB3 session beans), every datasource connection obtained
      internally by the entity manager will automatically be part of the
      global JTA transaction. Hibernate offers two strategies for this
      integration.</p><p>If you use bean-managed transactions (BMT), the code will look
      like this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;BMT&nbsp;idiom</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Resource</span><span class="java_plain">&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">UserTransaction</span><span class="java_plain">&nbsp;utx</span><span class="java_separator">;</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">Resource</span><span class="java_plain">&nbsp;</span><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">EntityManagerFactory</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">;</span>
</span>
<!--  --><br/><span class="java_keyword">public</span><span class="java_plain">&nbsp;</span><span class="java_type">void</span><span class="java_plain">&nbsp;doBusiness</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_type">EntityManager</span><span class="java_plain">&nbsp;em&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createEntityManager</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">try</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">do</span><span class="java_plain">&nbsp;some&nbsp;work</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_separator">...</span>
</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;utx</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">catch</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_type">RuntimeException</span><span class="java_plain">&nbsp;e</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">utx&nbsp;</span><span class="java_operator">!=</span><span class="java_plain">&nbsp;</span><span class="java_literal">null</span><span class="java_separator">)</span><span class="java_plain">&nbsp;utx</span><span class="java_separator">.</span><span class="java_plain">rollback</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;e</span><span class="java_separator">;</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;or&nbsp;display&nbsp;error&nbsp;message</span>
<!--  --><br/><span class="java_separator">}</span>
<!--  --><br/><span class="java_keyword">finally</span><span class="java_plain">&nbsp;</span><span class="java_separator">{</span>
<!--  --><br/><span class="java_plain">&nbsp;&nbsp;&nbsp;&nbsp;em</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_separator">}</span></pre><p>With Container Managed Transactions (CMT) in an EJB3 container,
      transaction demarcation is done in session bean annotations or
      deployment descriptors, not programatically. The
      <code class="literal">EntityManager</code> will automatically be flushed on
      transaction completion (and if you have injected or lookup the
      <code class="literal">EntityManager</code>, it will be also closed automatically).
      If an exception occurs during the <code class="literal">EntityManager</code> use,
      transaction rollback occurs automatically if you don't catch the
      exception. Since <code class="literal">EntityManager</code> exceptions are
      <code class="literal">RuntimeException</code>s they will rollback the transaction
      as per the EJB specification (system exception vs. application
      exception).</p><p>It is important to let Hibernate EntityManager define the
      <code class="literal">hibernate.transaction.factory_class</code> (ie not
      overriding this value). Remember to also set
      <code class="literal">org.hibernate.transaction.manager_lookup_class</code>.</p><p>If you work in a CMT environment, you might also want to use the
      same entity manager in different parts of your code. Typically, in a
      non-managed environment you would use a <code class="literal">ThreadLocal</code>
      variable to hold the entity manager, but a single EJB request might
      execute in different threads (e.g. session bean calling another session
      bean). The EJB3 container takes care of the persistence context
      propagation for you. Either using injection or lookup, the EJB3
      container will return an entity manager with the same persistence
      context bound to the JTA context if any, or create a new one and bind it
      (see <a href="architecture.html#architecture-ejb-persistctxpropagation" title="1.2.4. Persistence context propagation">Section 1.2.4, “Persistence context propagation”</a> .)</p><p>Our entity manager/transaction management idiom for CMT and EJB3
      container-use is reduced to this:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">CMT&nbsp;idiom&nbsp;through&nbsp;injection</span>
<!--  --><br/><span class="java_plain">@</span><span class="java_type">PersistenceContext</span><span class="java_separator">(</span><span class="java_plain">name</span><span class="java_operator">=</span><span class="java_literal">&quot;sample&quot;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_type">EntityManager</span><span class="java_plain">&nbsp;em</span><span class="java_separator">;</span></pre><p>Or this if you use Java Context and Dependency Injection
      (CDI).</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_plain">@</span><!-- <br/> --><span class="java_type">Inject</span><!-- <br/> --><span class="java_plain">&nbsp;</span><!-- <br/> --><span class="java_type">EntityManager</span><!-- <br/> --><span class="java_plain">&nbsp;em</span><!-- <br/> --><span class="java_separator">;</span></pre><p>In other words, all you have to do in a managed environment is to
      inject the <code class="literal">EntityManager</code>, do your data access work,
      and leave the rest to the container. Transaction boundaries are set
      declaratively in the annotations or deployment descriptors of your
      session beans. The lifecycle of the entity manager and persistence
      context is completely managed by the container.</p><p>Due to a silly limitation of the JTA spec, it is not possible for
      Hibernate to automatically clean up any unclosed
      <code class="literal">ScrollableResults</code> or <code class="literal">Iterator</code>
      instances returned by <code class="literal">scroll()</code> or
      <code class="literal">iterate()</code>. You <span class="emphasis"><em>must</em></span> release the
      underlying database cursor by calling
      <code class="literal">ScrollableResults.close()</code> or
      <code class="literal">Hibernate.close(Iterator)</code> explicitly from a
      <code class="literal">finally</code> block. (Of course, most applications can
      easily avoid using <code class="literal">scroll()</code> or
      <code class="literal">iterate()</code> at all from the CMT code.)</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-demarcation-exceptions"/>5.2.3. Exception handling</h3></div></div></div><p>If the <code class="literal">EntityManager</code> throws an exception
      (including any <code class="literal">SQLException</code>), you should immediately
      rollback the database transaction, call
      <code class="literal">EntityManager.close()</code> (if
      <code class="methodname">createEntityManager()</code> has been called) and
      discard the <code class="literal">EntityManager</code> instance. Certain methods
      of <code class="literal">EntityManager</code> will <span class="emphasis"><em>not</em></span> leave
      the persistence context in a consistent state. No exception thrown by an
      entity manager can be treated as recoverable. Ensure that the
      <code class="literal">EntityManager</code> will be closed by calling
      <code class="literal">close()</code> in a <code class="literal">finally</code> block. Note
      that a container managed entity manager will do that for you. You just
      have to let the RuntimeException propagate up to the container.</p><p>The Hibernate entity manager generally raises exceptions which
      encapsulate the Hibernate core exception. Common exceptions raised by
      the <code class="literal">EntityManager</code> API are</p><div class="itemizedlist"><ul><li><p><code class="classname">IllegalArgumentException</code>: something
          wrong happen</p></li><li><p><code class="classname">EntityNotFoundException</code>: an entity was
          expected but none match the requirement</p></li><li><p><code class="classname">NonUniqueResultException</code>: more than one
          entity is found when calling
          <code class="methodname">getSingleResult()</code></p></li><li><p>NoResultException: when
          <code class="methodname">getSingleResult()</code> does not find any
          matching entity</p></li><li><p><code class="classname">EntityExistsException</code>: an existing
          entity is passed to <code class="methodname">persist()</code></p></li><li><p><code class="classname">TransactionRequiredException</code>: this
          operation has to be in a transaction</p></li><li><p><code class="classname">IllegalStateException</code>: the entity
          manager is used in a wrong way</p></li><li><p><code class="classname">RollbackException</code>: a failure happens
          during <code class="methodname">commit()</code></p></li><li><p><code class="classname">QueryTimeoutException</code>: the query takes
          longer than the specified timeout (see
          <code class="literal">javax.persistence.query.timeout</code> - this property
          is a hint and might not be followed)</p></li><li><p><code class="classname">PessimisticLockException</code>: when a lock
          cannot be acquired</p></li><li><p><code class="classname">OptimisticLockException</code>: an optimistic
          lock is failing</p></li><li><p><code class="classname">LockTimeoutException</code>: when a lock takes
          longer than the expected time to be acquired
          (<code class="literal">javax.persistence.lock.timeout</code> in
          milliseconds)</p></li><li><p><code class="classname">TransactionRequiredException</code>: an
          operation requiring a transaction is executed outside of a
          transaction</p></li></ul></div><p>The <code class="literal">HibernateException</code>, which wraps most of the
      errors that can occur in a Hibernate persistence layer, is an unchecked
      exception. Note that Hibernate might also throw other unchecked
      exceptions which are not a <code class="literal">HibernateException</code>. These
      are, again, not recoverable and appropriate action should be
      taken.</p><p>Hibernate wraps <code class="literal">SQLException</code>s thrown while
      interacting with the database in a <code class="literal">JDBCException</code>. In
      fact, Hibernate will attempt to convert the exception into a more
      meaningful subclass of <code class="literal">JDBCException</code>. The underlying
      <code class="literal">SQLException</code> is always available via
      <code class="literal">JDBCException.getCause()</code>. Hibernate converts the
      <code class="literal">SQLException</code> into an appropriate
      <code class="literal">JDBCException</code> subclass using the
      <code class="literal">SQLExceptionConverter</code> attached to the
      <code class="literal">SessionFactory</code>. By default, the
      <code class="literal">SQLExceptionConverter</code> is defined by the configured
      dialect; however, it is also possible to plug in a custom implementation
      (see the javadocs for the
      <code class="literal">SQLExceptionConverterFactory</code> class for details). The
      standard <code class="literal">JDBCException</code> subtypes are:</p><div class="itemizedlist"><ul compact="compact"><li><p><code class="literal">JDBCConnectionException</code> - indicates an
          error with the underlying JDBC communication.</p></li><li><p><code class="literal">SQLGrammarException</code> - indicates a grammar
          or syntax problem with the issued SQL.</p></li><li><p><code class="literal">ConstraintViolationException</code> - indicates
          some form of integrity constraint violation.</p></li><li><p><code class="literal">LockAcquisitionException</code> - indicates an
          error acquiring a lock level necessary to perform the requested
          operation.</p></li><li><p><code class="literal">GenericJDBCException</code> - a generic exception
          which did not fall into any of the other categories.</p></li></ul></div></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2798"/>5.3. EXTENDED Persistence Context</h2></div></div></div><p>All application managed entity manager and container managed
    persistence contexts defined as such are <code class="literal">EXTENDED</code>. This
    means that the persistence context type goes beyond the transaction life
    cycle. We should then understand what happens to operations made outside
    the scope of a transaction.</p><p>In an <code class="literal">EXTENDED</code> persistence context, all read only
    operations of the entity manager can be executed outside a transaction
    (<code class="literal">find()</code>, <code class="literal">getReference()</code>,
    <code class="literal">refresh()</code>, <code class="methodname">detach()</code> and read
    queries). Some modifications operations can be executed outside a
    transaction, but they are queued until the persistence context join a
    transaction: this is the case of <code class="literal">persist()</code>,
    <code class="literal"><code class="literal">merge()</code></code>,
    <code class="literal">remove()</code>. Some operations cannot be called outside a
    transaction: <code class="literal">flush()</code>, <code class="literal">lock()</code>, and
    update/delete queries.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2839"/>5.3.1. Container Managed Entity Manager</h3></div></div></div><p>When using an <code class="literal">EXTENDED</code> persistence context with
      a container managed entity manager, the lifecycle of the persistence
      context is binded to the lifecycle of the Stateful Session Bean. Plus if
      the entity manager is created outside a transaction, modifications
      operations (persist, merge, remove) are queued in the persistence
      context and not executed to the database.</p><p>When a method of the stateful session bean involved or starting a
      transaction is later called, the entity manager join the transaction.
      All queued operation will then be executed to synchronize the
      persistence context.</p><p>This is perfect to implement the
      <code class="literal">entitymanager-per-conversation</code> pattern. A stateful
      session bean represents the conversation implementation. All
      intermediate conversation work will be processed in methods not
      involving transaction. The end of the conversation will be processed
      inside a <code class="literal">JTA</code> transaction. Hence all queued operations
      will be executed to the database and committed. If you are interested in
      the notion of conversation inside your application, have a look at JBoss
      Seam. JBoss Seam emphasizes the concept of conversation and entity
      manager lifecycle and bind EJB3 and JSF together.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="d0e2857"/>5.3.2. Application Managed Entity Manager</h3></div></div></div><p>Application-managed entity manager are always
      <code class="literal">EXTENDED</code>. When you create an entity manager inside a
      transaction, the entity manager automatically join the current
      transaction. If the entity manager is created outside a transaction, the
      entity manager will queue the modification operations. When</p><div class="itemizedlist"><ul><li><p><code class="methodname">entityManager.joinTransaction()</code> is
          called when a JTA transaction is active for a <code class="literal">JTA</code>
          entity manager</p></li><li><p><code class="literal">entityManager.getTransaction().begin()</code> is
          called for a <code class="literal">RESOURCE_LOCAL</code> entity manager</p></li></ul></div><p>the entity manager join the transaction and all the queued
      operations will then be executed to synchronize the persistence
      context.</p><p>It is not legal to call
      <code class="methodname">entityManager.joinTransaction()</code> if no JTA
      transaction is involved.</p></div></div><div class="sect1" lang="en"><div class="titlepage"><div><div><h2 class="title"><a id="transactions-optimistic"/>5.4. Optimistic concurrency control</h2></div></div></div><p>The only approach that is consistent with high concurrency and high
    scalability is optimistic concurrency control with versioning. Version
    checking uses version numbers, or timestamps, to detect conflicting
    updates (and to prevent lost updates). Hibernate provides for three
    possible approaches to writing application code that uses optimistic
    concurrency. The use cases we show are in the context of long application
    transactions but version checking also has the benefit of preventing lost
    updates in single database transactions.</p><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-manual"/>5.4.1. Application version checking</h3></div></div></div><p>In an implementation without much help from the persistence
      mechanism, each interaction with the database occurs in a new
      <code class="literal">EntityManager</code> and the developer is responsible for
      reloading all persistent instances from the database before manipulating
      them. This approach forces the application to carry out its own version
      checking to ensure application transaction isolation. This approach is
      the least efficient in terms of database access. It is the approach most
      similar to EJB2 entities:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;previous&nbsp;entity&nbsp;manager</span>
<!--  --><br/><span class="java_plain">em&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createEntityManager</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">EntityTransaction</span><span class="java_plain">&nbsp;t&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;em</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">int</span><span class="java_plain">&nbsp;oldVersion&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_type">Foo</span><span class="java_plain">&nbsp;dbFoo&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;em</span><span class="java_separator">.</span><span class="java_plain">find</span><span class="java_separator">(</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getClass</span><span class="java_separator">(),</span><span class="java_plain">&nbsp;foo</span><span class="java_separator">.</span><span class="java_plain">getKey</span><span class="java_separator">()</span><span class="java_plain">&nbsp;</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;load&nbsp;the&nbsp;current&nbsp;state</span>
<!--  --><br/><span class="java_keyword">if</span><span class="java_plain">&nbsp;</span><span class="java_separator">(</span><span class="java_plain">&nbsp;dbFoo</span><span class="java_separator">.</span><span class="java_plain">getVersion</span><span class="java_separator">()</span><span class="java_operator">!=</span><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">getVersion&nbsp;</span><span class="java_separator">)</span><span class="java_plain">&nbsp;</span><span class="java_keyword">throw</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;</span><span class="java_type">StaleObjectStateException</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">dbFoo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">t</span><span class="java_separator">.</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">em</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>The <code class="literal">version</code> property is mapped using
      <code class="literal">@Version</code>, and the entity manager will automatically
      increment it during flush if the entity is dirty.</p><p>Of course, if you are operating in a low-data-concurrency
      environment and don't require version checking, you may use this
      approach and just skip the version check. In that case, <span class="emphasis"><em>last
      commit wins</em></span> will be the default strategy for your long
      application transactions. Keep in mind that this might confuse the users
      of the application, as they might experience lost updates without error
      messages or a chance to merge conflicting changes.</p><p>Clearly, manual version checking is only feasible in very trivial
      circumstances and not practical for most applications. Often not only
      single instances, but complete graphs of modified objects have to be
      checked. Hibernate offers automatic version checking with either
      detached instances or an extended entity manager and persistence context
      as the design paradigm.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-longsession"/>5.4.2. Extended entity manager and automatic versioning</h3></div></div></div><p>A single persistence context is used for the whole application
      transaction. The entity manager checks instance versions at flush time,
      throwing an exception if concurrent modification is detected. It's up to
      the developer to catch and handle this exception (common options are the
      opportunity for the user to merge his changes or to restart the business
      process with non-stale data).</p><p>In an <code class="literal">EXTENDED</code> persistence context, all
      operations made outside an active transaction are queued. The
      <code class="literal">EXTENDED</code> persistence context is flushed when executed
      in an active transaction (at worse at commit time).</p><p>The <code class="literal">Entity Manager</code> is disconnected from any
      underlying JDBC connection when waiting for user interaction. In an
      application-managed extended entity manager, this occurs automatically
      at transaction completion. In a stateful session bean holding a
      container-managed extended entity manager (i.e. a SFSB annotated with
      <code class="literal">@PersistenceContext(EXTENDED)</code>), this occurs
      transparently as well. This approach is the most efficient in terms of
      database access. The application need not concern itself with version
      checking or with merging detached instances, nor does it have to reload
      instances in every database transaction. For those who might be
      concerned by the number of connections opened and closed, remember that
      the connection provider should be a connection pool, so there is no
      performance impact. The following examples show the idiom in a
      non-managed environment:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;earlier&nbsp;by&nbsp;the&nbsp;extended&nbsp;entity&nbsp;manager</span>
<!--  --><br/><span class="java_plain">em</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">.</span><span class="java_plain">begin</span><span class="java_separator">();</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_keyword">new</span><span class="java_plain">&nbsp;connection&nbsp;to&nbsp;data&nbsp;store&nbsp;is&nbsp;obtained&nbsp;and&nbsp;tx&nbsp;started</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">em</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span><span class="java_plain">&nbsp;&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;</span><span class="java_type">End</span><span class="java_plain">&nbsp;tx</span><span class="java_separator">,</span><span class="java_plain">&nbsp;flush&nbsp;and&nbsp;check&nbsp;version</span><span class="java_separator">,</span><span class="java_plain">&nbsp;disconnect</span></pre><p>The <code class="literal">foo</code> object still knows which
      <code class="literal">persistence context</code> it was loaded in. With
      <code class="literal">getTransaction.begin();</code> the entity manager obtains a
      new connection and resumes the persistence context. The method
      <code class="literal">getTransaction().commit()</code> will not only flush and
      check versions, but also disconnects the entity manager from the JDBC
      connection and return the connection to the pool.</p><p>This pattern is problematic if the persistence context is too big
      to be stored during user think time, and if you don't know where to
      store it. E.g. the <code class="literal">HttpSession</code> should be kept as
      small as possible. As the persistence context is also the (mandatory)
      first-level cache and contains all loaded objects, we can probably use
      this strategy only for a few request/response cycles. This is indeed
      recommended, as the persistence context will soon also have stale
      data.</p><p>It is up to you where you store the extended entity manager during
      requests, inside an EJB3 container you simply use a stateful session
      bean as described above. Don't transfer it to the web layer (or even
      serialize it to a separate tier) to store it in the
      <code class="literal">HttpSession</code>. In a non-managed, two-tiered environment
      the <code class="literal">HttpSession</code> might indeed be the right place to
      store it.</p></div><div class="sect2" lang="en"><div class="titlepage"><div><div><h3 class="title"><a id="transactions-optimistic-detached"/>5.4.3. Detached objects and automatic versioning</h3></div></div></div><p>With this paradigm, each interaction with the data store occurs in
      a new persistence context. However, the same persistent instances are
      reused for each interaction with the database. The application
      manipulates the state of detached instances originally loaded in another
      persistence context and then merges the changes using
      <code class="literal">EntityManager.merge()</code>:</p><pre xmlns="" xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" class="JAVA"><!-- <br/> --><span class="java_operator">//</span><!-- <br/> --><span class="java_plain">&nbsp;foo&nbsp;is&nbsp;an&nbsp;instance&nbsp;loaded&nbsp;by&nbsp;a&nbsp;non</span><!-- <br/> --><span class="java_operator">-</span><!-- <br/> --><span class="java_plain">extended&nbsp;entity&nbsp;manager</span>
<!--  --><br/><span class="java_plain">foo</span><span class="java_separator">.</span><span class="java_plain">setProperty</span><span class="java_separator">(</span><span class="java_literal">&quot;bar&quot;</span><span class="java_separator">);</span>
<!--  --><br/><span class="java_plain">entityManager&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;factory</span><span class="java_separator">.</span><span class="java_plain">createEntityManager</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">entityManager</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">begin</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">managedFoo&nbsp;</span><span class="java_operator">=</span><span class="java_plain">&nbsp;session</span><span class="java_separator">.</span><span class="java_plain">merge</span><span class="java_separator">(</span><span class="java_plain">foo</span><span class="java_separator">);</span><span class="java_plain">&nbsp;</span><span class="java_operator">//</span><span class="java_plain">&nbsp;discard&nbsp;foo&nbsp;and&nbsp;from&nbsp;now&nbsp;on&nbsp;use&nbsp;managedFoo</span>
<!--  --><br/><span class="java_plain">entityManager</span><span class="java_separator">.</span><span class="java_plain">getTransaction</span><span class="java_separator">().</span><span class="java_plain">commit</span><span class="java_separator">();</span>
<!--  --><br/><span class="java_plain">entityManager</span><span class="java_separator">.</span><span class="java_plain">close</span><span class="java_separator">();</span></pre><p>Again, the entity manager will check instance versions during
      flush, throwing an exception if conflicting updates occurred.</p></div></div></div><HR xmlns=""/><a xmlns="" href=""><p xmlns="http://www.w3.org/1999/xhtml" class="copyright">Copyright © 2005 Red Hat Inc. and the various authors</p></a><ul class="docnav"><li class="previous"><a accesskey="p" href="metamodel.html"><strong>Prev</strong>Chapter 4. Metamodel</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li><li class="next"><a accesskey="n" href="listeners.html"><strong>Next</strong>Chapter 6. Entity listeners and Callback methods</a></li></ul></body></html>